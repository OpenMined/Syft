import fastapi
from fastapi import Depends, HTTPException, Request
from pydantic import BaseModel

from syftbox.server.settings import ServerSettings, get_server_settings

from .auth import verify_admin_credentials, create_access_token, verify_current_user
from .user import User, UserManager, UserUpdate

user_router = fastapi.APIRouter(
    prefix="/users",
    tags=["users"],
)


def notify_user(user: User) -> None:
    print(f"New token {user.email}: {user.token}")


def get_user_manager(request: Request) -> UserManager:
    return request.state.user_manager


def get_user_by_email(email: str, user_manager: UserManager = Depends(get_user_manager)) -> User:
    user = user_manager.get_user(email)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@user_router.post("/register_tokens")
async def register_tokens(
    emails: list[str],
    user_manager: UserManager = Depends(get_user_manager),
    is_admin: bool = Depends(verify_admin_credentials),
) -> list[User]:
    """
    Register tokens for a list of emails.
    All users are created in the db with a random token, and an email is sent to each user.

    If the user already exists, the existing user is notified again with the same token.

    Args:
        emails (list[str]): list of emails to register.
        is_admin (bool, optional): checks if the user is an admin.
        user_manager (UserManager, optional): the user manager. Defaults to Depends(get_user_manager).

    Returns:
        list[User]: list of users created.
    """
    users = []
    for email in emails:
        user = user_manager.create_token_for_user(email)
        users.append(user)
        notify_user(user)

    return users


@user_router.post("/update")
async def update(
    user_update: UserUpdate,
    user: User = Depends(get_user_by_email),
    is_admin: bool = Depends(verify_admin_credentials),
    user_manager: UserManager = Depends(get_user_manager),
) -> User:
    user_update_dict = user_update.model_dump(exclude_unset=True)
    updated_user = user.model_copy(update=user_update_dict)
    result = user_manager.update_user(updated_user)
    return result


class RegisterResponse(BaseModel):
    bearer_token: str


@user_router.post("/register")
async def register(
    token: str,
    user: User = Depends(get_user_by_email),
    user_manager: UserManager = Depends(get_user_manager),
    server_settings: ServerSettings = Depends(get_server_settings),
) -> RegisterResponse:
    """Endpoint used by the user to register. This only works if the user has the correct token.
    Returns a bearer token that can be used to authenticate the user.

    Args:
        email (str): user email
        token (str): user token, generated by /register_tokens
    """
    if user.token != token:
        raise HTTPException(status_code=404, detail="Invalid token")

    updated_user = user.model_copy(update={"is_registered": True})
    user_manager.update_user(updated_user)

    bearer_token = create_access_token(user, server_settings)
    return RegisterResponse(bearer_token=bearer_token)
